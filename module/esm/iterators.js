import { deferred } from "./deferred.js";
export function isAsyncIterator(o) {
    return typeof o?.next === 'function';
}
export function isAsyncIterable(o) {
    return o && o[Symbol.asyncIterator] && typeof o[Symbol.asyncIterator] === 'function';
}
export function isAsyncIter(o) {
    return isAsyncIterable(o) || isAsyncIterator(o);
}
export function asyncIterator(o) {
    if (isAsyncIterable(o))
        return o[Symbol.asyncIterator]();
    if (isAsyncIterator(o))
        return o;
    throw new Error("Not as async provider");
}
/* A function that wraps a "prototypical" AsyncIterator helper, that has `this:AsyncIterable<T>` and returns
  something that's derived from AsyncIterable<R>, result in a wrapped function that accepts
  the same arguments returns a AsyncExtraIterable<X>
*/
function wrapAsyncHelper(fn) {
    return function (...args) { return iterableHelpers(fn.call(this, ...args)); };
}
export const asyncExtras = {
    map: wrapAsyncHelper(map),
    filter: wrapAsyncHelper(filter),
    unique: wrapAsyncHelper(unique),
    throttle: wrapAsyncHelper(throttle),
    debounce: wrapAsyncHelper(debounce),
    waitFor: wrapAsyncHelper(waitFor),
    count: wrapAsyncHelper(count),
    retain: wrapAsyncHelper(retain),
    broadcast: wrapAsyncHelper(broadcast),
    initially: wrapAsyncHelper(initially),
    consume: consume,
    merge(...m) {
        return merge(this, ...m);
    }
};
class QueueIteratableIterator {
    constructor(stop = () => { }) {
        this.stop = stop;
        this._pending = [];
        this._items = [];
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    next() {
        if (this._items.length) {
            return Promise.resolve({ done: false, value: this._items.shift() });
        }
        const value = deferred();
        // We install a catch handler as the promise might be legitimately reject before anything waits for it,
        // and this suppresses the uncaught exception warning.
        value.catch(ex => { });
        this._pending.push(value);
        return value;
    }
    return() {
        const value = { done: true, value: undefined };
        if (this._pending) {
            try {
                this.stop();
            }
            catch (ex) { }
            while (this._pending.length)
                this._pending.shift().reject(value);
            this._items = this._pending = null;
        }
        return Promise.resolve(value);
    }
    throw(...args) {
        const value = { done: true, value: args[0] };
        if (this._pending) {
            try {
                this.stop();
            }
            catch (ex) { }
            while (this._pending.length)
                this._pending.shift().reject(value);
            this._items = this._pending = null;
        }
        return Promise.resolve(value);
    }
    push(value) {
        if (!this._pending) {
            //throw new Error("pushIterator has stopped");
            return false;
        }
        if (this._pending.length) {
            this._pending.shift().resolve({ done: false, value });
        }
        else {
            this._items.push(value);
        }
        return true;
    }
}
/* An AsyncIterable which typed objects can be published to.
  The queue can be read by multiple consumers, who will each receive
  unique values from the queue (ie: the queue is SHARED not duplicated)
*/
export function pushIterator(stop = () => { }, bufferWhenNoConsumers = false) {
    let consumers = 0;
    let ai = new QueueIteratableIterator(() => {
        consumers -= 1;
        if (consumers === 0 && !bufferWhenNoConsumers) {
            try {
                stop();
            }
            catch (ex) { }
            // This should never be referenced again, but if it is, it will throw
            ai = null;
        }
    });
    return Object.assign(Object.create(asyncExtras), {
        [Symbol.asyncIterator]() {
            consumers += 1;
            return ai;
        },
        push(value) {
            if (!bufferWhenNoConsumers && consumers === 0) {
                // No one ready to read the results
                return false;
            }
            return ai.push(value);
        },
        close(ex) {
            ex ? ai.throw?.(ex) : ai.return?.();
            // This should never be referenced again, but if it is, it will throw
            ai = null;
        }
    });
}
/* An AsyncIterable which typed objects can be published to.
  The queue can be read by multiple consumers, who will each receive
  a copy of the values from the queue (ie: the queue is BROADCAST not shared).

  The iterators stops running when the number of consumers decreases to zero
*/
export function broadcastIterator(stop = () => { }) {
    let ai = new Set();
    const b = Object.assign(Object.create(asyncExtras), {
        [Symbol.asyncIterator]() {
            const added = new QueueIteratableIterator(() => {
                ai.delete(added);
                if (ai.size === 0) {
                    try {
                        stop();
                    }
                    catch (ex) { }
                    // This should never be referenced again, but if it is, it will throw
                    ai = null;
                }
            });
            ai.add(added);
            return iterableHelpers(added);
        },
        push(value) {
            if (!ai?.size)
                return false;
            for (const q of ai.values()) {
                q.push(value);
            }
            return true;
        },
        close(ex) {
            for (const q of ai.values()) {
                ex ? q.throw?.(ex) : q.return?.();
            }
            // This should never be referenced again, but if it is, it will throw
            ai = null;
        }
    });
    return b;
}
export function defineIterableProperty(o, name, v) {
    // Make `a` an AsyncExtraIterable. We don't do this until a consumer actually tries to
    // access the iterator methods to prevent leaks where an iterable is created, but
    // never referenced, and therefore cannot be consumed and ultimately closed
    let initIterator = () => {
        initIterator = () => b;
        const bi = broadcastIterator();
        extras[Symbol.asyncIterator] = { value: bi[Symbol.asyncIterator], enumerable: false, writable: false };
        push = bi.push;
        const b = bi[Symbol.asyncIterator]();
        Object.keys(asyncHelperFunctions).map(k => extras[k] = { value: b[k], enumerable: false, writable: false });
        Object.defineProperties(a, extras);
        return b;
    };
    // Create stubs that lazily create the AsyncExtraIterable interface when invoked
    const lazyAsyncMethod = (method) => function (...args) {
        initIterator();
        return a[method].call(this, ...args);
    };
    const extras = {
        [Symbol.asyncIterator]: {
            enumerable: false, writable: true,
            value: initIterator
        }
    };
    Object.keys(asyncHelperFunctions).map(k => extras[k] = {
        enumerable: false,
        writable: true,
        value: lazyAsyncMethod(k)
    });
    // Lazily initialize `push`
    let push = (v) => {
        initIterator(); // Updates `push` to reference the broadvaster
        return push(v);
    };
    let a = box(v, extras);
    let vi;
    Object.defineProperty(o, name, {
        get() { return a; },
        set(v) {
            /*
            Potential code to allow setting of an iterable property from another iterator
            ** It doesn't work as it is asynchronously recursive **
            if (isAsyncIter(v)) {
              if (vi) {
                vi.return?.();
              }
              vi = asyncIterator(v) as AsyncIterator<V>;
              const update = () => vi!.next().then(es => {
                if (es.done) {
                  vi = undefined;
                } else {
                  a = box(es.value, extras);
                  push(es.value?.valueOf() as V);
                  update();
                }
              }).catch(ex => {
                console.log(ex);
                //vi!.throw?.(ex);
                vi = undefined;
              });
              update();
            } else
            */ {
                a = box(v, extras);
                push(v?.valueOf());
            }
        },
        enumerable: true
    });
    return o;
}
function box(a, pds) {
    if (a === null || a === undefined) {
        return Object.create(null, {
            ...pds,
            valueOf: { value() { return a; } },
            toJSON: { value() { return a; } }
        });
    }
    switch (typeof a) {
        case 'object':
            /* TODO: This is problematic as the object might have clashing keys.
              The alternatives are:
              - Don't add the pds, then the object remains unmolested, but can't be used with .map, .filter, etc
              - examine the object and decide whether to insert the prototype (breaks built in objects, works with PoJS)
              - don't allow objects as iterable properties, which avoids the `deep tree` problem
              - something else
            */
            if (!(Symbol.asyncIterator in a)) {
                console.warn('Iterable properties of type "object" will be modified. Spread the object if necessary.');
                return Object.defineProperties(a, pds);
            }
            return a;
        case 'bigint':
        case 'boolean':
        case 'number':
        case 'string':
            // Boxes types, including BigInt
            return Object.defineProperties(Object.assign(a), {
                ...pds,
                toJSON: { value() { return a.valueOf(); } }
            });
    }
    throw new TypeError('Iterable properties cannot be of type "' + typeof a + '"');
}
export const merge = (...ai) => {
    const it = ai.map(i => Symbol.asyncIterator in i ? i[Symbol.asyncIterator]() : i);
    const promises = it.map((i, idx) => i.next().then(result => ({ idx, result })));
    const results = [];
    const forever = new Promise(() => { });
    let count = promises.length;
    const merged = {
        [Symbol.asyncIterator]() { return this; },
        next() {
            return count
                ? Promise.race(promises).then(({ idx, result }) => {
                    if (result.done) {
                        count--;
                        promises[idx] = forever;
                        results[idx] = result.value;
                        return { done: count === 0, value: result.value };
                    }
                    else {
                        // `ex` is the underlying async iteration exception
                        promises[idx] = it[idx].next().then(result => ({ idx, result })).catch(ex => ({ idx, result: ex }));
                        return result;
                    }
                }).catch(ex => {
                    return this.throw?.(ex) ?? Promise.reject({ done: true, value: new Error("Iterator merge exception") });
                })
                : Promise.reject({ done: true, value: new Error("Iterator merge complete") });
        },
        return() {
            const ex = new Error("Merge terminated");
            for (let i = 0; i < it.length; i++) {
                if (promises[i] !== forever) {
                    promises[i] = forever;
                    it[i].return?.({ done: true, value: ex }); // Terminate the sources with the appropriate cause
                }
            }
            return Promise.resolve({ done: true, value: ex });
        },
        throw(ex) {
            for (let i = 0; i < it.length; i++) {
                if (promises[i] !== forever) {
                    promises[i] = forever;
                    it[i].throw?.(ex); // Terminate the sources with the appropriate cause
                }
            }
            // Because we've passed the exception on to all the sources, we're now done
            // previously: return Promise.reject(ex);
            return Promise.resolve({ done: true, value: ex });
        }
    };
    return iterableHelpers(merged);
};
/*
  Extensions to the AsyncIterable:
  calling `bind(ai)` adds "standard" methods to the specified AsyncIterable
*/
function isExtraIterable(i) {
    return isAsyncIterable(i)
        && Object.keys(asyncExtras)
            .every(k => (k in i) && i[k] === asyncExtras[k]);
}
// Attach the pre-defined helpers onto an AsyncIterable and return the modified object correctly typed
export function iterableHelpers(ai) {
    if (!isExtraIterable(ai)) {
        Object.assign(ai, asyncExtras);
    }
    return ai;
}
export function generatorHelpers(g) {
    // @ts-ignore: TS type madness
    return function (...args) {
        // @ts-ignore: TS type madness
        return iterableHelpers(g(...args));
    };
}
/* AsyncIterable helpers, which can be attached to an AsyncIterator with `withHelpers(ai)`, and invoked directly for foreign asyncIterators */
async function* map(...mapper) {
    const ai = this[Symbol.asyncIterator]();
    try {
        while (true) {
            const p = await ai.next();
            if (p.done) {
                return ai.return?.(p.value);
            }
            for (const m of mapper)
                yield m(p.value);
        }
    }
    catch (ex) {
        ai.throw?.(ex);
    }
    finally {
        ai.return?.();
    }
}
async function* filter(fn) {
    const ai = this[Symbol.asyncIterator]();
    try {
        while (true) {
            const p = await ai.next();
            if (p.done) {
                return ai.return?.(p.value);
            }
            if (await fn(p.value)) {
                yield p.value;
            }
        }
    }
    catch (ex) {
        ai.throw?.(ex);
    }
    finally {
        ai.return?.();
    }
}
const noUniqueValue = Symbol('noUniqueValue');
async function* unique(fn) {
    const ai = this[Symbol.asyncIterator]();
    let prev = noUniqueValue;
    try {
        while (true) {
            const p = await ai.next();
            if (p.done) {
                return ai.return?.(p.value);
            }
            if (fn && prev !== noUniqueValue ? await fn(p.value, prev) : p.value != prev) {
                yield p.value;
            }
            prev = p.value;
        }
    }
    catch (ex) {
        ai.throw?.(ex);
    }
    finally {
        ai.return?.();
    }
}
async function* initially(initValue) {
    yield initValue;
    for await (const u of this)
        yield u;
}
async function* throttle(milliseconds) {
    const ai = this[Symbol.asyncIterator]();
    let paused = 0;
    try {
        while (true) {
            const p = await ai.next();
            if (p.done) {
                return ai.return?.(p.value);
            }
            const now = Date.now();
            if (paused < now) {
                paused = now + milliseconds;
                yield p.value;
            }
        }
    }
    catch (ex) {
        ai.throw?.(ex);
    }
    finally {
        ai.return?.();
    }
}
const forever = new Promise(() => { });
// NB: DEBOUNCE IS CURRENTLY BROKEN
async function* debounce(milliseconds) {
    const ai = this[Symbol.asyncIterator]();
    let timer = forever;
    let last = -1;
    try {
        while (true) {
            const p = await Promise.race([ai.next(), timer]);
            if ('done' in p && p.done)
                return ai.return?.(p.value);
            if ('debounced' in p && p.debounced) {
                if (p.debounced === last)
                    yield p.value;
            }
            else {
                // We have a new value from the src
                clearTimeout(last);
                timer = new Promise(resolve => {
                    last = setTimeout(() => {
                        resolve({ debounced: last, value: p.value });
                    }, milliseconds);
                });
            }
        }
    }
    catch (ex) {
        ai.throw?.(ex);
    }
    finally {
        ai.return?.();
    }
}
async function* waitFor(cb) {
    const ai = this[Symbol.asyncIterator]();
    try {
        while (true) {
            const p = await ai.next();
            if (p.done) {
                return ai.return?.(p.value);
            }
            await new Promise(resolve => cb(resolve));
            yield p.value;
        }
    }
    catch (ex) {
        ai.throw?.(ex);
    }
    finally {
        ai.return?.();
    }
}
async function* count(field) {
    const ai = this[Symbol.asyncIterator]();
    let count = 0;
    try {
        for await (const value of this) {
            const counted = {
                ...value,
                [field]: count++
            };
            yield counted;
        }
    }
    catch (ex) {
        ai.throw?.(ex);
    }
    finally {
        ai.return?.();
    }
}
function retain() {
    const ai = this[Symbol.asyncIterator]();
    let prev;
    return {
        [Symbol.asyncIterator]() { return this; },
        next() {
            const n = ai.next();
            n.then(p => prev = p);
            return n;
        },
        return(value) {
            return ai.return?.(value) ?? Promise.resolve({ done: true, value });
        },
        throw(...args) {
            return ai.throw?.(args) ?? Promise.resolve({ done: true, value: args[0] });
        },
        get value() {
            return prev.value;
        },
        get done() {
            return Boolean(prev.done);
        }
    };
}
function broadcast() {
    const ai = this[Symbol.asyncIterator]();
    const b = broadcastIterator(() => ai.return?.());
    (function update() {
        ai.next().then(v => {
            if (v.done) {
                // Meh - we throw these away for now.
                // console.log(".broadcast done");
            }
            else {
                b.push(v.value);
                update();
            }
        }).catch(ex => b.close(ex));
    })();
    return {
        [Symbol.asyncIterator]() {
            return b[Symbol.asyncIterator]();
        }
    };
}
async function consume(f) {
    let last = undefined;
    for await (const u of this)
        last = f?.(u);
    await last;
}
const asyncHelperFunctions = { map, filter, unique, throttle, debounce, waitFor, count, retain, broadcast, initially, consume, merge };
